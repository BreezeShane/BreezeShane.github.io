"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderAtom = void 0;
const convert = require("xml-js");
const utils_1 = require("../utils");
const genAuthororContributor = (author) => {
    const { name, email, url } = author;
    return Object.assign(Object.assign({ name }, (email ? { email } : {})), (url ? { uri: utils_1.encodeXML(url) } : {}));
};
const genCategory = (category) => {
    const { name, scheme } = category;
    return {
        _attributes: {
            term: name,
            scheme,
        },
    };
};
/**
 * Returns an Atom 1.0 feed
 *
 * @see http://www.atomenabled.org/developers/syndication/
 */
const renderAtom = (feed) => {
    const { channel, links } = feed.options;
    const content = {
        _declaration: {
            _attributes: {
                version: "1.0",
                encoding: "utf-8",
            },
        },
        feed: Object.assign(Object.assign(Object.assign({ _attributes: Object.assign({ xmlns: "http://www.w3.org/2005/Atom" }, (channel.language ? { "xml:lang": channel.language } : {})), id: channel.link, title: channel.title }, (channel.description ? { subtitle: channel.description } : {})), (channel.author
            ? { author: genAuthororContributor(channel.author) }
            : {})), { updated: channel.lastUpdated
                ? channel.lastUpdated.toISOString()
                : new Date().toISOString(), generator: utils_1.generator, link: [{ _attributes: { rel: "self", href: utils_1.encodeXML(links.atom) } }] }),
    };
    if (channel.link)
        content.feed.link.push({
            _attributes: { rel: "alternate", href: utils_1.encodeXML(channel.link) },
        });
    if (channel.hub)
        content.feed.link.push({
            _attributes: { rel: "hub", href: utils_1.encodeXML(channel.hub) },
        });
    if (channel.image)
        content.feed.logo = channel.image;
    if (channel.icon)
        content.feed.icon = channel.icon;
    if (channel.copyright)
        content.feed.rights = channel.copyright;
    content.feed.category = Array.from(feed.categories).map((category) => ({
        _attributes: { term: category },
    }));
    content.feed.contributor = Array.from(feed.contributors)
        .filter((contributor) => contributor.name)
        .map((contributor) => genAuthororContributor(contributor));
    /**
     * "entry" nodes
     */
    content.feed.entry = feed.items.map((item) => {
        // entry: required elements
        const entry = {
            title: { _attributes: { type: "html" }, _text: utils_1.encodeXML(item.title) },
            id: utils_1.encodeXML(item.guid || item.link),
            link: { _attributes: { href: utils_1.encodeXML(item.link) } },
            updated: item.lastUpdated.toISOString(),
        };
        // entry: recommended elements
        if (item.description)
            entry.summary = {
                _attributes: { type: "html" },
                _cdata: utils_1.encodeCDATA(item.description),
            };
        if (item.content)
            entry.content = {
                _attributes: { type: "html" },
                _cdata: utils_1.encodeCDATA(item.content),
            };
        // author(s)
        if (Array.isArray(item.author))
            entry.author = item.author
                .filter((author) => author.name)
                .map((author) => genAuthororContributor(author));
        else if (item.author && item.author.name)
            entry.author = [genAuthororContributor(item.author)];
        if (Array.isArray(item.category))
            // category
            entry.category = item.category.map((category) => genCategory(category));
        else if (item.category)
            entry.category = [genCategory(item.category)];
        // contributor
        if (Array.isArray(item.contributor))
            entry.contributor = item.contributor.map((contributor) => genAuthororContributor(contributor));
        // published
        if (item.pubDate)
            entry.published = item.pubDate.toISOString();
        // rights
        if (item.copyright)
            entry.rights = item.copyright;
        return entry;
    });
    return convert.js2xml(content, {
        compact: true,
        ignoreComment: true,
        spaces: 2,
    });
};
exports.renderAtom = renderAtom;
//# sourceMappingURL=index.js.map