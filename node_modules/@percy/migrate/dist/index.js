"use strict";

var _fs = require("fs");

var _command = _interopRequireWildcard(require("@oclif/command"));

var _config = _interopRequireDefault(require("@percy/config"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _inquirer = _interopRequireDefault(require("inquirer"));

var _inspect = _interopRequireDefault(require("./inspect"));

var _migrations = _interopRequireDefault(require("./migrations"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_inquirer.default.registerPrompt('glob', require('inquirer-glob-prompt'));

class Migrate extends _command.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "log", Object.assign(this.log, (0, _logger.default)('migrate')));
  }

  // Initialize flags, args, the loglevel, and attach process handlers for cleanup
  init() {
    let {
      args,
      flags
    } = this.parse();
    this.flags = flags;
    this.args = args; // sets the log level from verbose, quiet, and silent flags

    _logger.default.loglevel('info', flags);
  } // Run migration steps


  async run() {
    // inspect dependencies
    let info = (0, _inspect.default)(); // get the desired sdk migration

    let sdk = !this.flags['only-cli'] && (await this.confirmSDK(info, this.args.sdk_name)); // install @percy/cli and migrate config

    if (!this.flags['skip-cli']) {
      await this.confirmCLI(info);
      await this.confirmConfig();
    } // perform sdk migration


    if (sdk !== null && sdk !== void 0 && sdk.upgrade) {
      await this.confirmUpgrade(sdk);
      await this.confirmTransforms(sdk);
      this.log.info('Migration complete!');
    } else {
      if (sdk) this.log.warn('Make sure your SDK is upgraded to the latest version!');
      this.log.info('See further migration instructions here: ' + 'https://docs.percy.io/docs/migrating-to-percy-cli');
    }
  } // Confirms installing @percy/cli and possibly removing @percy/agent


  async confirmCLI({
    agent,
    cli
  }) {
    if (cli) return;
    let {
      installCLI,
      skipCLI
    } = await _inquirer.default.prompt([{
      type: 'confirm',
      name: 'installCLI',
      message: `Install @percy/cli ${agent ? '(and remove @percy/agent)?' : '(required to run percy)?'}`,
      default: true
    }, {
      type: 'confirm',
      name: 'skipCLI',
      when: ({
        installCLI
      }) => !installCLI,
      message: 'Are you sure you want to skip installing @percy/cli?',
      default: false
    }]);

    if (installCLI || !skipCLI) {
      if (agent) await _utils.npm.uninstall('@percy/agent');
      await _utils.npm.install('@percy/cli');
    }
  } // Confirms possibly running config file migration


  async confirmConfig() {
    try {
      let {
        filepath
      } = _config.default.search();

      if (!filepath) return;
    } catch (error) {
      this.log.error(error);
      return;
    }

    let {
      doConfig
    } = await _inquirer.default.prompt([{
      type: 'confirm',
      name: 'doConfig',
      message: 'Migrate Percy config file?',
      default: true
    }]);

    if (doConfig) {
      let percybin = `${process.cwd()}/node_modules/@percy/cli/bin/run`;

      if (!(0, _fs.existsSync)(percybin)) {
        this.log.warn('Could not run config migration, @percy/cli is not installed');
      } else {
        await (0, _utils.run)(percybin, ['config:migrate']);
      }
    }
  } // Confirms if the first SDK in the list is the current SDK, otherwise will present a list of
  // supported SDKs to choose from, erroring when the chosen SDK is not in the list


  async confirmSDK({
    installed,
    inspected
  }, name) {
    let sdk;

    let fromInstalled = SDK => {
      let sdk = installed.find(sdk => sdk instanceof SDK) || new SDK();

      if (!sdk.installed && inspected.includes(sdk.language)) {
        this.log.warn('The specified SDK was not found in your dependencies');
      }

      return sdk;
    }; // don't guess when a name is provided


    if (name) {
      let SDK = _migrations.default.find(SDK => SDK.matches(name));

      if (!SDK) this.log.warn('The specified SDK is not supported');else sdk = fromInstalled(SDK);
    } else {
      [sdk] = installed;
    } // confirm the specified or guessed sdk


    if (sdk) {
      let {
        isSDK
      } = await _inquirer.default.prompt([{
        type: 'confirm',
        name: 'isSDK',
        message: `Are you currently using ${sdk.aliased}?`,
        default: true
      }]);

      if (isSDK) {
        return sdk;
      }
    } // ask to choose from list of supported sdks


    let {
      fromChoice
    } = await _inquirer.default.prompt([{
      type: 'list',
      name: 'fromChoice',
      message: 'Which SDK are you using?',
      default: sdk ? _migrations.default.indexOf(sdk.constructor) : 0,
      choices: _migrations.default.map(SDK => ({
        name: SDK.aliased,
        value: () => fromInstalled(SDK)
      })).concat({
        name: '...not listed?',
        value: null
      })
    }]);
    return fromChoice === null || fromChoice === void 0 ? void 0 : fromChoice();
  } // Confirms if the SDK needs an upgrade and performs the upgrade


  async confirmUpgrade(sdk) {
    if (!sdk.needsUpgrade) return;
    let {
      upgradeSDK
    } = await _inquirer.default.prompt([{
      type: 'confirm',
      name: 'upgradeSDK',
      message: `Upgrade SDK to ${sdk.name}@${sdk.version}?`,
      default: true
    }]);

    if (upgradeSDK) {
      await sdk.upgrade();
    }
  } // Confirms running available SDK transforms


  async confirmTransforms(sdk) {
    for (let t of sdk.transforms) {
      var _t$when;

      if (sdk.installed && ((_t$when = t.when) === null || _t$when === void 0 ? void 0 : _t$when.call(t, sdk.installed)) === false) {
        continue;
      }

      let {
        doTransform
      } = await _inquirer.default.prompt([{
        type: 'confirm',
        name: 'doTransform',
        message: t.message,
        default: true
      }]);

      if (!doTransform) {
        continue;
      }

      let {
        filePaths
      } = await _inquirer.default.prompt([{
        type: 'glob',
        name: 'filePaths',
        message: 'Which files?',
        default: t.default,
        glob: {
          ignore: 'node_modules'
        }
      }]);

      if (!(filePaths !== null && filePaths !== void 0 && filePaths.length)) {
        this.log.error('Could not find any files matching the pattern');
        continue;
      }

      await t.transform.call(sdk, filePaths);
    }
  } // Log errors using the Percy logger


  async catch(err) {
    try {
      // real errors will bubble
      await super.catch(err);
    } catch (err) {
      // oclif exit method actually throws an error, let it continue
      if (err.oclif && err.code === 'EEXIT') throw err; // log all other errors and exit

      this.log.error(err);
      this.exit(err.status || 1);
    }
  }

}

_defineProperty(Migrate, "description", 'Upgrade and migrate your Percy SDK to the latest version');

_defineProperty(Migrate, "args", [{
  name: 'sdk_name',
  description: 'name of the Percy SDK to migrate (detected by default)'
}]);

_defineProperty(Migrate, "flags", {
  // version && help
  version: _command.flags.version({
    char: 'v'
  }),
  help: _command.flags.help({
    char: 'h'
  }),
  // cli installation
  'only-cli': _command.flags.boolean({
    description: 'only run @percy/cli installation'
  }),
  'skip-cli': _command.flags.boolean({
    description: 'skip @percy/cli installation'
  }),
  // logging
  verbose: _command.flags.boolean({
    char: 'v',
    description: 'log everything',
    exclusive: ['quiet', 'silent']
  }),
  quiet: _command.flags.boolean({
    char: 'q',
    description: 'log errors only',
    exclusive: ['verbose', 'silent']
  }),
  silent: _command.flags.boolean({
    description: 'log nothing',
    exclusive: ['verbose', 'quiet']
  })
});

_defineProperty(Migrate, "examples", ['$ npx @percy/migrate', '$ npx @percy/migrate @percy/puppeteer', '$ npx @percy/migrate --only-cli']);

module.exports = Migrate;