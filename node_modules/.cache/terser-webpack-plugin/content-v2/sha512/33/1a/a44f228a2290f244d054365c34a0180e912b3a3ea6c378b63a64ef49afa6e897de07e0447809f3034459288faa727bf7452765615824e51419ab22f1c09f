{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{524:function(t,a,s){\"use strict\";s.r(a);var n=s(1),_=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"h1\",{attrs:{id:\"wasserstein-generative-adversarial-networks\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#wasserstein-generative-adversarial-networks\"}},[t._v(\"#\")]),t._v(\" Wasserstein Generative Adversarial Networks\")]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"首推这篇博客，本文内容多参考自此。\"),s(\"a\",{attrs:{href:\"https://www.cnblogs.com/Allen-rg/p/10305125.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"WGAN (原理解析)\"),s(\"OutboundLink\")],1)]),t._v(\" \"),s(\"p\",[t._v(\"本文也另外参考了这篇\"),s(\"a\",{attrs:{href:\"https://lotabout.me/2018/WGAN/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"博客\"),s(\"OutboundLink\")],1)])]),t._v(\" \"),s(\"h2\",{attrs:{id:\"结果\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#结果\"}},[t._v(\"#\")]),t._v(\" 结果！\")]),t._v(\" \"),s(\"p\",[t._v(\"尽管表现差了些，但也比之前的Qriginal GAN要强多了，这里出现了训练不稳定的情况，但还不至于直接导致梯度消失问题。\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"/images/wgan-1.png\",alt:\"\"}})]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"/images/wgan-2.png\",alt:\"\"}})]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"/images/wgan-3.png\",alt:\"\"}})]),t._v(\" \"),s(\"p\",[t._v(\"从最终结果来看，成绩还没那么糟糕，较多数的点也聚集在黄点的区域附近了。\")]),t._v(\" \"),s(\"h2\",{attrs:{id:\"原因\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原因\"}},[t._v(\"#\")]),t._v(\" 原因?\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"原始gan的缺陷\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原始gan的缺陷\"}},[t._v(\"#\")]),t._v(\" 原始GAN的缺陷\")]),t._v(\" \"),s(\"p\",[s(\"em\",[s(\"strong\",[t._v(\"通俗的解释就是，判别器训练的太好，以至于生成器训练不动！\")])])]),t._v(\" \"),s(\"p\",[t._v(\"我们先来看一下Original GAN的损失函数：\")]),t._v(\" \"),s(\"p\",[t._v(\"$$\\nL(G,D)=2D_{JS}(P_r||P_g)-2log2\\n$$\")]),t._v(\" \"),s(\"p\",[t._v(\"为避免你遗忘，再复习一下这两个定义：\")]),t._v(\" \"),s(\"p\",[t._v(\"$$\\nD_{KL}(p||q)=\\\\int_x p(x)log\\\\frac{p(x)}{q(x)}dx\\n$$\")]),t._v(\" \"),s(\"p\",[t._v(\"$$\\nD_{JS}= \\\\frac{1}{2}D_{KL}(p||\\\\frac{p+q}{2})+\\\\frac{1}{2}D_{KL}(q||\\\\frac{p+q}{2})\\n$$\")]),t._v(\" \"),s(\"p\",[t._v(\"根据前一篇的推导，我们可以看到，如果我们能缩小这个JS散度的话，就可以把真实分布和生成分布拉近了，而这正是我们希望看到的，生成器生成的东西会更接近真实。\")]),t._v(\" \"),s(\"p\",[t._v(\"**然而现实总是残酷的，问题就出现在这个JS散度上。**我们对它的希望只能在两个分布有所重叠且重叠部分不可忽略的情况下才能成立。反过来说就是，如果两个分布没有重叠或者有可忽略的重叠，JS散度的结果只能是一个常数（ lg2，可自行验证），而常数意味着梯度必然为0！\")]),t._v(\" \"),s(\"p\",[t._v(\"我们试着探究一下，对于任意一个x，必然分如下四种情况：\")]),t._v(\" \"),s(\"p\",[t._v(\"$$P_1(x)=0\\\\wedge P_2(x)=0$$；$$P_1(x)\\\\not=0\\\\wedge P_2(x)\\\\not=0$$；\")]),t._v(\" \"),s(\"p\",[t._v(\"$$P_1(x)\\\\not=0\\\\wedge P_2(x)=0$$；$$P_1(x)=0\\\\wedge P_2(x)\\\\not=0$$。\")]),t._v(\" \"),s(\"p\",[t._v(\"对于第一种情况是对JS散度无贡献的；而第二种情况又因为重叠部分可忽略以至于贡献过小，也可看作无贡献；而对于后两种情况，计算结果皆为lg2。\")]),t._v(\" \"),s(\"p\",[t._v(\"而真实分布和生成分布不重叠或者重叠部分可忽略的情况出现的可能性有多大？可以说非常大。而严格来说，则是当$P_r$和$P_g$的支撑集\"),s(\"sup\",{staticClass:\"footnote-ref\"},[s(\"a\",{attrs:{href:\"#footnote1\"}},[t._v(\"[1]\")]),s(\"a\",{staticClass:\"footnote-anchor\",attrs:{id:\"footnote-ref1\"}})]),t._v(\"是高维空间中的低维流形\"),s(\"sup\",{staticClass:\"footnote-ref\"},[s(\"a\",{attrs:{href:\"#footnote2\"}},[t._v(\"[2]\")]),s(\"a\",{staticClass:\"footnote-anchor\",attrs:{id:\"footnote-ref2\"}})]),t._v(\"时$P_r$和$P_g$重叠部分测度\"),s(\"sup\",{staticClass:\"footnote-ref\"},[s(\"a\",{attrs:{href:\"#footnote3\"}},[t._v(\"[3]\")]),s(\"a\",{staticClass:\"footnote-anchor\",attrs:{id:\"footnote-ref3\"}})]),t._v(\"为0的概率为1。\")]),t._v(\" \"),s(\"p\",[t._v(\"有了如上三个概念，我们再想，一般生成器都是从低维空间中随机生成某一编码向量，再通过神经网络生成高维数据，然而尽管最后数据是高维的，可实质上的维度还是和编码向量维度相同或者比编码向量维度还小（考虑到神经网络带来的映射降维）——因为向量的所有变化都只能分布在低维空间中，而所有的变化又与高维数据形成映射，也就是说，高维空间中的事件空间仅含有低维空间内的所有变化，而不包含高维空间的其余部分。「这就是这位博主说的“撑不满”整个高维空间的意思。」\")]),t._v(\" \"),s(\"p\",[t._v(\"正是有上面的“撑不满”的问题，真实分布和生成分布就很难有重叠部分，首先要明白，我们寻找的重叠部分实际上是和真实分布、生成分布同维的，那么在整个高维空间中，两个分布即使能相交，得到的重叠部分只能是低维流形，这对于我们要找到的重叠部分而言差的很远，测度显然为0（可能没有测度，也可能测度过小而可忽略）。\")]),t._v(\" \"),s(\"p\",[t._v(\"综上所述，在（近似）最优判别器中，最小化生成器$L(G,D)$等价于最小化$P_r$和$P_g$的JS散度，然而当$P_r$和$P_g$不重叠或者重叠部分测度为0时，无论两个分布相距多远，JS散度始终是lg2，导致梯度几乎为0，梯度消失，生成器就无法训练。\")]),t._v(\" \"),s(\"p\",[t._v(\"而我们再宏观把握这个问题：\")]),t._v(\" \"),s(\"p\",[t._v(\"1.由于$P_r$和$P_g$几乎不能有不可忽略的重叠，不论两者实际的距离有多小，必然存在一个最优分割曲面能恰好将两者隔开，而且仅仅是那些测度为0的重叠部分不能被隔开。\")]),t._v(\" \"),s(\"p\",[t._v(\"2.以神经网络为主体的判别器可无限拟合上面提到的曲面，从而能够出现这样一个最优判别器，对几乎整个真实分布给出概率为1，而对几乎整个生成分布给出概率为0，而只有那些可忽略的测度为0的部分，最优判别器才不能很好地分类。\")]),t._v(\" \"),s(\"p\",[t._v(\"3.判别器对真实分布和生成分布的概率是常数，这造成生成器损失函数的梯度变成0。\")]),t._v(\" \"),s(\"p\",[t._v(\"这下就清楚原始GAN的问题所在了：如果判别器训练得太好，生成器的梯度就消失，Loss函数无法下降；如果判别器训练得不好，生成器梯度不准，会生成许多无用的样本。只有将判别器训练得恰到好处才能表现良好，然而这一点非常难做到，像博主所说，“在同一轮训练的前后不同阶段这个火候都可能不一样”，因此原始GAN非常难训练。\")]),t._v(\" \"),s(\"p\",[t._v(\"后来Lan Goodfellow提出了一种改进方式，将生成器的Loss改成$\\\\mathbb{E}\"),s(\"em\",[t._v(\"{x\\\\sim p_g}[-\\\\log D(x)]$，然后将KL散度变换成含判别器D的形式：\\n$$\\n\\\\begin {align}\\nKL(P_g||P_r)&=\\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_g}[\\\\log \\\\cfrac\"+t._s(t.P_g(t.x))+\"{P_r(x)}] \\\\nonumber \\\\\\n&=\\\\mathbb{E}\"),s(\"em\",[t._v(\"{x \\\\sim P_g}[\\\\log \\\\frac{\\\\cfrac{P_g(x)}{P_r(x)+P_g(x)}}{\\\\cfrac{P_r(x)}{P_r(x)+P_g(x)}}] \\\\nonumber \\\\\\n&=\\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_g}[\\\\log \\\\cfrac\"+t._s(1-t.D(t.x))+\"{D(x)}] \\\\nonumber \\\\\\n&=\\\\mathbb{E}\"),s(\"em\",[t._v(\"{x \\\\sim P_g}\\\\log[1-D(x)]-\\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_g}\\\\log D(x)\\n\\\\end{align}\\n$$\")]),t._v(\" \"),s(\"p\",[t._v(\"$$\\n\\\\begin{eqnarray}\\n\\\\mathbb{E}\"),s(\"em\",[t._v(\"{x\\\\sim p_g}[-\\\\log D(x)]&=&KL(P_g||P_r)-\\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_g}\\\\log[1-D(x)]\\\\\\n&=&KL(P_g||P_r)-2JS(P_r||P_g)+2\\\\log2+\\\\mathbb{E}_{x \\\\sim P_r}\\\\log D(x)\\n\\\\end{eqnarray}\\n$$\")]),t._v(\" \"),s(\"p\",[t._v(\"很容易看出来最后两项不依赖生成器，因而最小化该公式就等价于最小化$KL(P_g||P_r)-2JS(P_r||P_g)$，但很明显，这是在同时做两件相互矛盾的事——既要最小化KL散度，又要最大化JS散度（回顾之前我写的Original GAN可知，JS本身就是在以KL散度来定义）。尽管看起来可能像构成博弈，但最后造成了梯度不稳定。\")]),t._v(\" \"),s(\"p\",[t._v(\"另外，前面的KL散度项也存在问题，因为KL散度本身不是对称的衡量，$KL(P_g||P_r)$和$KL(P_r||P_g)$是有区别的，为什么要提及不对称的问题？我们看一下关于$KL(P_g||P_r)$的两种情况：\")]),t._v(\" \"),s(\"p\",[t._v(\"当$P_g(x)\\\\to 0,P_r(x)\\\\to 1$时，$P_g(x)\\\\log\\\\frac{P_g(x)}{P_r(x)}\\\\to0$，对$KL(P_g||P_r)$的贡献趋近于0；\")]),t._v(\" \"),s(\"p\",[t._v(\"当$P_g(x)\\\\to 1,P_r(x)\\\\to 0$时，$P_g(x)\\\\log\\\\frac{P_g(x)}{P_r(x)}\\\\to +\\\\infty$，对$KL(P_g||P_r)$的贡献趋近于正无穷。\")]),t._v(\" \"),s(\"p\",[t._v(\"这代表什么意思？一言以蔽之，惩罚失衡。对于第一种情况，生成器没能生成真实的样本，惩罚却微小，而对于第二种情况，生成器生成了不真实的样本，惩罚却巨大。这样会导致生成器宁可生成重复但不会错的样本，也不会去生成多样的样本。其实这就是常见的collapse mode。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"wgan前作的改进\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#wgan前作的改进\"}},[t._v(\"#\")]),t._v(\" WGAN前作的改进\")]),t._v(\" \"),s(\"p\",[t._v(\"WGAN前作针对生成器随机初始化后的生成分布很难与真实分布有不可忽略的重叠的问题提出了一种解决方案：向生成样本和真实样本添加噪声。这样就让原本的两个低维流形强行弥散到整个高维空间，从而使两者产生不可忽略的重叠。\")]),t._v(\" \"),s(\"p\",[t._v(\"显然一旦存在重叠，JS散度就可以发挥作用，当两个分布靠近的时候，JS散度也会减小，而不再是恒为常数了，这样就可以解决生成器梯度消失问题了。训练过程中还可以对添加的噪声进行退火，缓慢减小其方差，直到最后两个低维流体已经有不可忽略的重叠的时候把噪声完全拿掉，JS也能正常发挥作用，继续拉近两个低维流形，直到他们接近完全重合为止。\")]),t._v(\" \"),s(\"p\",[t._v(\"采取这样的方案后，对原来的损失函数\\n$$\\n\\\\mathbb{E}\"),s(\"em\",[t._v(\"{x\\\\sim P_r(x)}[\\\\log D(x)]+\\\\mathbb{E}\")]),t._v(\"{x\\\\sim P_g(x)}[\\\\log(1-D(x))]=2JS(P_r||P_g)-2\\\\log2\\n$$\")]),t._v(\" \"),s(\"p\",[t._v(\"取反可得判别器最小loss为\")]),t._v(\" \"),s(\"p\",[t._v(\"$$\\nminL_D(P_{r+\\\\epsilon},P_{g+\\\\epsilon})=-\\\\mathbb{E}\"),s(\"em\",[t._v(\"{x\\\\sim P\")]),t._v(\"{r+\\\\epsilon}[\\\\log D(x)]}-\\\\mathbb{E}\"),s(\"em\",[t._v(\"{x\\\\sim P\")]),t._v(\"{g+\\\\epsilon}}[\\\\log(1-D(x))]\\n$$\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"wgan-出现的全过程\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#wgan-出现的全过程\"}},[t._v(\"#\")]),t._v(\" WGAN 出现的全过程\")]),t._v(\" \"),s(\"p\",[t._v(\"在这里就要引入一个新的概念：Wasserstein距离（又称Earth-Mover距离、EM距离），定义如下：\\n$$\\nW(P_r,P_g)=\\\\underset{\\\\gamma\\\\sim\\\\Pi(P_r,P_g)}{inf}\\\\mathbb{E}\"),s(\"em\",[t._v(\"{(x,y)\\\\sim\\\\gamma}[||x-y||]\\n$$\\n其中$$\\\\Pi(P_r,P_g)$$是$$P_r$$和$$P_g$$组合起来的所有可能的联合分布集合，显然，其边缘分布为$$P_r$$和$$P_g$$。又由于对每一个可能的联合分布$\\\\gamma$而言，总可以从$$\\\\Pi(P_r,P_g)$$中采样$$(x, y)\\\\sim\\\\gamma$$得到一个真实样本$$x$$和生成样本$$y$$，并算出这两个样本的距离$$||x-y||$$，就可以借此算出该联合分布$$\\\\gamma$$下样本对距离的期望值$$E\")]),t._v(\"{(x,y)\\\\sim\\\\gamma}[||x-y||]$$，在所有可能的联合分布中取到这些期望值的下界$$\\\\underset{\\\\gamma\\\\sim\\\\Pi(P_r,P_g)}{inf}\\\\mathbb{E}_{(x,y)\\\\sim\\\\gamma}[||x-y||]$$，这个下界就被定义为Wasserstein距离。\")]),t._v(\" \"),s(\"table\",[s(\"font\",{attrs:{color:\"#7FFF00\",size:\"4\"}},[t._v(\"这里直接引用博主的解释，博主的讲解还是比较准确的：\"),s(\"br\"),t._v(\"\\n    直观上可以把\\\\$\\\\mathbb{E}_{(x, y) \\\\sim \\\\gamma} [||x - y||]\\\\$理解为在\\\\$\\\\gamma\\\\$这个“路径规划”下把\\\\$P_r\\\\$这堆“沙土”挪到\\\\$P_g\\\\$“位置”所需的“消耗”，而\\\\$W(P_r, P_g)\\\\$就是“最优路径规划”下的“最小消耗”，所以才叫Earth-Mover（推土机）距离。\")])],1),t._v(\" \"),s(\"p\",[t._v(\"Wasserstein距离相比KL散度和JS散度的优势在于，即使真实分布和生成分布没有任何重叠，Wasserstein距离仍然能够反映它们的远近程度。下面我们来做一个平行比较：\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"/images/2021-05-11_20-00.png\",alt:\"\"}})]),t._v(\" \"),s(\"center\",[s(\"font\",{attrs:{color:\"#00FFFF\",size:\"3\"}},[t._v(\"其中\\\\$P_1\\\\$表示在线段AB上的分布，\\\\$P_2\\\\$表示在线段CD上的分布\")])],1),t._v(\" \"),s(\"p\",[t._v(\"$$\\nKL(P_1||P_2)=\\n\\\\begin{cases}\\n+\\\\infty & \\\\text{if 𝜗≠0}\\\\\\n0 & \\\\text{if 𝜗=0}\\n\\\\end{cases}\\\\ \\\\quad\\\\quad\\nJS(P_1||P_2)=\\n\\\\begin{cases}\\n+\\\\infty & \\\\text{if 𝜗≠0}\\\\\\n0 & \\\\text{if 𝜗=0}\\n\\\\end{cases}\\\\ \\\\quad\\\\quad\\nW(P_1,P_2)=|\\\\vartheta|\\n$$\\n从中我们不难发现，KL散度、JS散度在𝜗=0附近发生突变，这意味着在𝜗=0处不可导，因而不可能存在梯度，更谈何下降？\")]),t._v(\" \"),s(\"p\",[t._v(\"那么我们理解Wasserstein距离之后，该如何构建GAN网络模型呢？将它定义为生成器的Loss函数，产生有意义的梯度，从而将生成分布拉向真实分布吗？然而我们回看这个定义，会发现如果要求解$$\\\\underset{\\\\gamma\\\\sim\\\\Pi(P_r,P_g)}{inf}$$的话，按照定义我们应该把每一个期望值都算出来，然后去寻找下界。很明显这效率不高，也几乎无法实现。不过作者用了一系列定理得出一套能使用的公式：\\n$$\\nW(P_r, P_g) = \\\\frac{1}{K} \\\\sup_{||f||\"),s(\"em\",[t._v(\"L \\\\leq K} \\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_r} [f(x)] - \\\\mathbb{E}_{x \\\\sim P_g} [f(x)]\\n$$\\n具体过程请去查阅\"),s(\"a\",{attrs:{href:\"https://arxiv.org/abs/1701.07875\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"相关论文\"),s(\"OutboundLink\")],1),t._v(\"的附录C。\")]),t._v(\" \"),s(\"p\",[t._v(\"在进一步解释这个公式之前，我们需要知道利普希茨连续（Lipschitz Continuity）的概念：\")]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"对于在实数集的子集的函数${\\\\displaystyle f\\\\colon D\\\\subseteq \\\\mathbb {R} \\\\to \\\\mathbb {R} }$，若存在常数${\\\\displaystyle K}$，使得$|f(a)-f(b)|\\\\leq K|a-b|\\\\quad \\\\forall a,b\\\\in D$，则称${\\\\displaystyle f}$符合利普希茨条件，对于$f$最小的常数${\\\\displaystyle K}$称为 ${\\\\displaystyle f}$的利普希茨常数。\")]),t._v(\" \"),s(\"p\",[t._v(\"若$K<1$，$f$称为收缩映射。\")]),t._v(\" \"),s(\"p\",[t._v(\"利普希茨条件也可对任意度量空间的函数定义：\")]),t._v(\" \"),s(\"p\",[t._v(\"给定两个度量空间$$(M,d_{M}),(N,d_{N}),U\\\\subseteq M$$。若对于函数$f:U\\\\to N$，存在常数$K$使得$$d_{N}(f(a),f(b))\\\\leq Kd_{M}(a,b)\\\\quad \\\\forall a,b\\\\in U$$\\n则说它符合利普希茨条件。\")]),t._v(\" \"),s(\"p\",[t._v(\"若存在$K\\\\geq 1$使得$${\\\\frac{1}{K}}d_{M}(a,b)\\\\leq d_{N}(f(a),f(b))\\\\leq Kd_{M}(a,b)\\\\quad \\\\forall a,b\\\\in U$$\\n则称$f$为\"),s(\"strong\",[t._v(\"双李普希茨\")]),t._v(\"(bi-Lipschitz)。\")]),t._v(\" \"),s(\"p\",{attrs:{align:\"right\"}},[t._v(\"——摘自\"),s(\"a\",{attrs:{href:\"https://zh.wikipedia.org/wiki/%E5%88%A9%E6%99%AE%E5%B8%8C%E8%8C%A8%E9%80%A3%E7%BA%8C\",title:\"利普希茨连续\"}},[t._v(\"维基百科\")])])]),t._v(\" \"),s(\"p\",[t._v(\"这里要特别指出，博主在这里给出的解释是不准确的，利普希茨连续函数$f(x)$不一定处处可微。\")]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"它其实就是在一个连续函数$f$上面额外施加了一个限制，要求存在一个常数$K\\\\geq 0$使得定义域内的任意两个元素$x_1$和$x_2$都满足$|f(x_1) - f(x_2)| \\\\leq K |x_1 - x_2|$，此时称函数f的Lipschitz常数为K。\")])]),t._v(\" \"),s(\"p\",[t._v(\"如果用数学方式说明，则已知$f(x)$是利普希茨连续函数，\\n$$\\n\\\\because a\\\\not=b \\\\\\n\\\\text{由定义知当}|a-b|\\\\to0\\\\text{时，}\\\\exists K\\\\text{使得}\\\\frac{|f(a)-f(b)|}{|a-b|}\\\\leq K。 \\\\\\n\\\\text{而}\\n\\\\left.\\n\\\\begin{aligned}\\n\\\\lim_{|a-b|\\\\to0^+}\\\\frac{|f(a)-f(b)|}{|a-b|}\\\\leq K \\\\\\n\\\\lim_{|a-b|\\\\to0^-}\\\\frac{|f(a)-f(b)|}{|a-b|}\\\\leq K\\n\\\\end{aligned}\\n\\\\right}\\\\not\\\\Rightarrow\\\\lim_{|a-b|\\\\to0^+}\\\\frac{|f(a)-f(b)|}{|a-b|} = \\\\lim_{|a-b|\\\\to0^-}\\\\frac{|f(a)-f(b)|}{|a-b|}\\n$$\\n另外再提起一个函数$f(x)=|x|$，$$f^\\\\prime(x)=\\\\begin{cases}1 & x\\\\geq0\\\\ -1&x<0\\\\end{cases}$$，显然可以发现它是利普希茨连续函数，因为它符合利普希茨连续条件的定义。而对于$x=0$处却不可微「左导数和右导数不等而导致导数不存在」。\")]),t._v(\" \"),s(\"p\",[t._v(\"因此个人认为应该这样理解：利普希茨连续函数是广义的有限制的连续函数，广义指的是不需要处处可微，有限制指的是导函数有界。显然利普希茨连续条件限制了函数的最大局部变化幅度。\")]),t._v(\" \"),s(\"p\",[t._v(\"下面的这个公式\\n$$\\nW(P_r, P_g) = \\\\frac{1}{K} \\\\sup_{||f||\"),s(\"em\",[t._v(\"L \\\\leq K} \\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_r} [f(x)] - \\\\mathbb{E}\"),s(\"em\",[t._v(\"{x \\\\sim P_g} [f(x)] \\\\quad\\\\quad(A)\\n$$\\n在要求$$||f||\"),s(\"em\",[t._v(\"L \\\\leq K$$的条件下对所有可能满足条件的$$f$$取到$$\\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_r} [f(x)] - \\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_g} [f(x)]$$的上界，再缩小K倍。\")]),t._v(\" \"),s(\"p\",[t._v(\"如果存在某函数$f_\\\\omega$，这函数由$\\\\omega$个参数确定，则(A)式可以写成：\\n$$\\nW(P_r, P_g) \\\\approx \\\\frac{1}{K} \\\\max_{\\\\omega|f_\\\\omega|\"),s(\"em\",[t._v(\"L \\\\leq K} \\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_r} [f_\\\\omega(x)] - \\\\mathbb{E}\"),s(\"em\",[t._v(\"{x \\\\sim P_g} [f\")]),t._v(\"\\\\omega(x)] \\\\quad \\\\quad (B)\\n$$\\n这样定义出来的函数虽然不能囊括所有可能，至少可以足够接近我们希望求得的原式。那么如何得到上面提到的函数？「由$\\\\omega$个参数确定」不觉得熟悉吗？这个其实就可以用神经网络模型来拟合。那么就可以在(B)式的基础上定义Loss函数了，只要能寻找出上界就可以，由于我们只有梯度下降求解器，我们需要适当使用图形变换技巧转化一下(B)式，比如取其相反数。\")]),t._v(\" \"),s(\"p\",[t._v(\"最后还不能忘记公式的前提条件$||f||_L \\\\leq K$，当然，$K$究竟有多大这无关紧要「不是无穷大就行」，因为我们只是需要梯度的方向。那么如何满足这个条件？作者采取的做法是始终将神经网络内的参数$\\\\omega_i$限制在闭区间$[-c,c]$，这样关于输入样本$x$的导数就会被限制在确定的范围，至于到底是什么范围，就不是我们关心的了，有界就行。\")]),t._v(\" \"),s(\"p\",[t._v(\"现在我们构造一下判别器的损失函数。含参数$\\\\omega$、最后一层不是非线性激活层的判别器网络$f_\\\\omega$在限制$\\\\omega$不超过某个范围的条件下，使\\n$$\\nL = \\\\mathbb{E}\"),s(\"em\",[t._v(\"{x \\\\sim P_r} [f_w(x)] - \\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_g} [f_w(x)]\\n$$\\n取到最大，此时$L$就会接近真实分布与生成分布之间的Wasserstein距离「忽略系数$K$」。\")]),t._v(\" \"),s(\"table\",[s(\"tr\",[s(\"td\",{attrs:{bgcolor:\"#FF6347\"}},[s(\"strong\",[t._v(\"这里要特别注意一下的是：\"),s(\"br\"),t._v(\"Original GAN的判别器要做的是真假二分类任务，因此最后一层才会采用sigmoid函数处理，而现在WGAN的判别器做的是近似拟合Wasserstein距离，是回归问题，因此最后一层不使用非线性结构，要把sigmoid函数去掉。\")])])])]),t._v(\" \"),s(\"p\",[t._v(\"接着要与判别器博弈的生成器需要近似最小化Wasserstein距离，也就是最小化$L$，前面足够充分讲解了Wasserstein距离的优良性质，我们不用再担心会有梯度消失的问题。另外$L$的第一项只与判别器有关而与生成器无关，因此生成器的损失函数不含$ \\\\mathbb{E}_{x \\\\sim P_r} [f_w(x)] $这一项「因为这一项会是常数」。\")]),t._v(\" \"),s(\"h2\",{attrs:{id:\"最终整个wgan就有两个loss函数。-begin-eqnarray-1-quad-quad-l-g-mathbb-e-x-sim-p-g-f-w-x-2-quad-quad-l-d-mathbb-e-x-sim-p-g-f-w-x-mathbb-e-x-sim-p-r-f-w-x-end-eqnarray\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#最终整个wgan就有两个loss函数。-begin-eqnarray-1-quad-quad-l-g-mathbb-e-x-sim-p-g-f-w-x-2-quad-quad-l-d-mathbb-e-x-sim-p-g-f-w-x-mathbb-e-x-sim-p-r-f-w-x-end-eqnarray\"}},[t._v(\"#\")]),t._v(\" 最终整个WGAN就有两个Loss函数。\\n$$\\n\\\\begin{eqnarray}\\n&(1)&\\\\quad\\\\quad L_G=-\\\\mathbb{E}\"),s(\"em\",[t._v(\"{x\\\\sim P_g}[f_w(x)]\\\\\\n&(2)&\\\\quad\\\\quad L_D=\\\\mathbb{E}\")]),t._v(\"{x \\\\sim P_g} [f_w(x)]- \\\\mathbb{E}_{x \\\\sim P_r} [f_w(x)]\\n\\\\end{eqnarray}\\n$$\")]),t._v(\" \"),s(\"center\",[s(\"strong\",[s(\"i\",[s(\"font\",{attrs:{color:\"#ADFF2F\"}},[t._v(\"~~~现在万事具备，只欠东风，我们立即开始实现~~~\")])],1)])]),t._v(\" \"),s(\"h2\",{attrs:{id:\"实现\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现\"}},[t._v(\"#\")]),t._v(\" 实现！\")]),t._v(\" \"),s(\"p\",[t._v(\"只消在Original GAN代码的基础上再加上：\")]),t._v(\" \"),s(\"div\",{staticClass:\"language-python line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-python\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"def\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"weights_init\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"m\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"if\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[t._v(\"isinstance\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"m\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" nn\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"Linear\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\"\\n        \"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"# m.weight.data.normal_(0.0, 0.02)\")]),t._v(\"\\n        nn\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"init\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"kaiming_normal_\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"m\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"weight\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n        m\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"bias\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"data\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"fill_\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"4\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"5\")]),s(\"br\")])]),s(\"p\",[t._v(\"然后在main函数中初始化变量_clip为0.025「你也可以自己设定」，然后在声明的G和D后面插入两行代码：\")]),t._v(\" \"),s(\"div\",{staticClass:\"language-python line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-python\"}},[s(\"code\",[t._v(\"G\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[t._v(\"apply\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"weights_init\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\nD\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[t._v(\"apply\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"weights_init\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\")])]),s(\"p\",[t._v(\"并在判别器训练的代码块后生成器训练的代码块之前添加如下代码：\")]),t._v(\" \"),s(\"div\",{staticClass:\"language-python line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-python\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"for\")]),t._v(\" w \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"in\")]),t._v(\" D\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"parameters\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\"\\n\\tw\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"data\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"clamp_\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"-\")]),t._v(\"_clip\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" _clip\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\")])]),s(\"p\",[t._v(\"为了出现上面贴的图，我将后面的\"),s(\"code\",[t._v(\"if epoch %\")]),t._v(\"后的数改成10，\"),s(\"code\",[t._v(\"for epoch in range\")]),t._v(\"后括号内的数改成1000。\")]),t._v(\" \"),s(\"p\",[t._v(\"到此为止代码也就改完了，我们的WGAN也实现了！\")]),t._v(\" \"),s(\"p\",[t._v(\"完整代码请点这里查看--\\x3e\"),s(\"a\",{attrs:{href:\"https://github.com/BreezeShane/Unsupervised-Learning/blob/master/Wasserstein%20Generative%20Adversaria%20Networks.py\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"·\"),s(\"OutboundLink\")],1)]),t._v(\" \"),s(\"hr\"),t._v(\" \"),s(\"h2\",{attrs:{id:\"睿智-作者的话-不重要\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#睿智-作者的话-不重要\"}},[t._v(\"#\")]),t._v(\" \"),s(\"strong\",[t._v(\"“睿智”作者的话（不重要）\")])]),t._v(\" \"),s(\"p\",[t._v(\"光是学WGAN到写这长篇报（fèi）告（huà）就花了快半个月了，也是多艰多难啊！不过最终总算是完成了，完结撒花🌸撒花！🌸～～～\")]),t._v(\" \"),s(\"p\",[t._v(\"如果想学无监督学习，数学真的是硬核，对线性代数、概率论要求比较高，涉及的数学领域也很广，就目前来看，我见过的有涉及实分析、线性代数、概率论、数学分析、凸分析、复分析等的知识，虽然学到了些许特别零碎的可能没什么用的小知识点。\")]),t._v(\" \"),s(\"p\",[t._v(\"不过不得不感叹的是我非常敬佩Martin Arjovsky等人，只是做了简单的四处改动，却能获得如此惊人的成效，从根本上解决Original GAN难训练、不稳定的问题，不错的\"),s(\"s\",[t._v(\"战斗\")]),t._v(\"成果，即使是我也会感到心潮澎湃！🤣🤣🤣\")]),t._v(\" \"),s(\"hr\",{staticClass:\"footnotes-sep\"}),t._v(\" \"),s(\"section\",{staticClass:\"footnotes\"},[s(\"ol\",{staticClass:\"footnotes-list\"},[s(\"li\",{staticClass:\"footnote-item\",attrs:{id:\"footnote1\"}},[s(\"p\",[t._v(\"指的是函数的非零部分子集。一个概率分布的支撑集就是所有概率密度非零部分的集合。「个人认为可以和函数的定义域或者命题的论域等做类比理解。」 \"),s(\"a\",{staticClass:\"footnote-backref\",attrs:{href:\"#footnote-ref1\"}},[t._v(\"↩︎\")])])]),t._v(\" \"),s(\"li\",{staticClass:\"footnote-item\",attrs:{id:\"footnote2\"}},[s(\"p\",[t._v(\"是高维空间中曲线、曲面概念的拓广，比如在三维空间中任一曲面都是二维流形，任一曲线是一维流形。 \"),s(\"a\",{staticClass:\"footnote-backref\",attrs:{href:\"#footnote-ref2\"}},[t._v(\"↩︎\")])])]),t._v(\" \"),s(\"li\",{staticClass:\"footnote-item\",attrs:{id:\"footnote3\"}},[s(\"p\",[t._v(\"是高维空间中长度、面积、体积概念的推广，在这里可以大致理解为超体积。 \"),s(\"a\",{staticClass:\"footnote-backref\",attrs:{href:\"#footnote-ref3\"}},[t._v(\"↩︎\")])])])])])],1)}),[],!1,null,null,null);a.default=_.exports}}]);","extractedComments":[]}