import{_ as t,W as e,X as p,a1 as a,Y as s,Z as n}from"./framework-68a75bb9.js";const o={},l=a(`<h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>双链表，即表中每一个结点都有两个指针，分别指向前驱和后继。</p><p>结构代码的定义：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> data <span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>llink<span class="token punctuation">,</span> <span class="token operator">*</span>rlink <span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果希望对双链表做一次封装，可以额外使用如下的代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">Hnode</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>双链表的出现是为了解决单链表不能直接访问前驱的问题。</p><h2 id="双向炼表的基本操作与实现" tabindex="-1"><a class="header-anchor" href="#双向炼表的基本操作与实现" aria-hidden="true">#</a> 双向炼表的基本操作与实现</h2><h3 id="创建" tabindex="-1"><a class="header-anchor" href="#创建" aria-hidden="true">#</a> 创建</h3><p><strong>实现思路</strong>：</p><p>创建好相关的封装，并在此基础上创建双链表中的头结点，彼此相连构建成一个空的双链表。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">Hnode</span> <span class="token operator">*</span><span class="token function">createDlist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">Hnode</span><span class="token operator">*</span> HEAD <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Hnode</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Hnode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> headNode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    headNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    headNode<span class="token operator">-&gt;</span>llink <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    headNode<span class="token operator">-&gt;</span>rlink <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    HEAD<span class="token operator">-&gt;</span>head <span class="token operator">=</span> headNode<span class="token punctuation">;</span>
    HEAD<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> headNode<span class="token punctuation">;</span>
    <span class="token keyword">return</span> HEAD<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,13),c=s("p",null,[s("strong",null,"时间复杂度"),n("：该函数仅做有限的操作，显然时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),i=s("p",null,[s("strong",null,"空间复杂度"),n("：该函数申请的空间大小与用户输入规模不相关，因此认为空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),r=a(`<h3 id="插入" tabindex="-1"><a class="header-anchor" href="#插入" aria-hidden="true">#</a> 插入</h3><p><strong>实现思路</strong>：</p><p>如果双链表为空，则需完成如下的操作：</p><ol><li>头结点指向新结点</li><li>新结点左指针指向头结点</li><li>封装的尾指针指向尾结点</li></ol><p>如果双链表非空，则需按照如下顺序执行：</p><ol><li>头结点后继的左指针指向新结点</li><li>新结点右指针指向头结点后继</li><li>新结点左指针指向头结点</li><li>头结点右指针指向新结点</li></ol><p><strong>「注意」</strong>：该情况下第四点必须要在第一、二点之后做，其他顺序任意调整即可。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">insertDlist</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Hnode</span> <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">int</span> insData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> headNode <span class="token operator">=</span> list<span class="token operator">-&gt;</span>head<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> insData<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>headNode <span class="token operator">==</span> list<span class="token operator">-&gt;</span>tail<span class="token punctuation">)</span><span class="token punctuation">{</span>
        headNode<span class="token operator">-&gt;</span>rlink <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        newNode<span class="token operator">-&gt;</span>llink <span class="token operator">=</span> headNode<span class="token punctuation">;</span>
        list<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        headNode<span class="token operator">-&gt;</span>rlink<span class="token operator">-&gt;</span>llink <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        newNode<span class="token operator">-&gt;</span>rlink <span class="token operator">=</span> headNode<span class="token operator">-&gt;</span>rlink<span class="token punctuation">;</span>
        newNode<span class="token operator">-&gt;</span>llink <span class="token operator">=</span> headNode<span class="token punctuation">;</span>
        headNode<span class="token operator">-&gt;</span>rlink <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    headNode<span class="token operator">-&gt;</span>data<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),u=s("p",null,[s("strong",null,"时间复杂度"),n("：该插入操作执行次数与用户输入规模不相关，每一次插入都是固定执行这些语句，因此认为时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),d=s("p",null,[s("strong",null,"空间复杂度"),n("：该插入操作只需要申请固定变量所占的空间大小，因此认为该操作空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),k=a(`<h3 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h3><p><strong>实现思路</strong>：</p><p>遍历每一个结点，找到要删除的数据时，将其前驱的右指针指向该结点的后继，其后继的左指针指向该结点的前驱，然后释放该空间。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">deleteData</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Hnode</span>  <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">int</span> delData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> watcher <span class="token operator">=</span> list<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>rlink<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> toDel <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token operator">-&gt;</span>data <span class="token operator">==</span> delData<span class="token punctuation">)</span><span class="token punctuation">{</span>
            toDel <span class="token operator">=</span> watcher<span class="token punctuation">;</span>
            watcher<span class="token operator">-&gt;</span>llink<span class="token operator">-&gt;</span>rlink <span class="token operator">=</span> watcher<span class="token operator">-&gt;</span>rlink<span class="token punctuation">;</span>
            watcher<span class="token operator">-&gt;</span>rlink<span class="token operator">-&gt;</span>llink <span class="token operator">=</span> watcher<span class="token operator">-&gt;</span>llink<span class="token punctuation">;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>toDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        watcher <span class="token operator">=</span> watcher<span class="token operator">-&gt;</span>rlink<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),m=s("p",null,[s("strong",null,"时间复杂度"),n("：该操作执行次数与用户输入的规模线性相关，显然时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),h=s("p",null,[s("strong",null,"空间复杂度"),n("：该操作只需要在原有数据的基础上做操作，申请固定的变量空间大小，因此空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),v=a(`<h3 id="输出" tabindex="-1"><a class="header-anchor" href="#输出" aria-hidden="true">#</a> 输出</h3><p><strong>实现思路</strong>：</p><p>遍历每一个结点并输出，终止条件应该是指针为空时。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">printDlist</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Hnode</span> <span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//输出双向循环链表中各数据元素的值，每输出一个数据元素换行</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> watcher <span class="token operator">=</span> list<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>rlink<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> watcher<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        watcher <span class="token operator">=</span> watcher<span class="token operator">-&gt;</span>rlink<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),g=s("p",null,[s("strong",null,"时间复杂度"),n("：该操作与用户输入规模线性相关，因此时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),w=s("p",null,[s("strong",null,"空间复杂度"),n("：该操作只需要在原有数据的基础上做操作，申请固定的变量空间大小，因此空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),b=a(`<h3 id="销毁" tabindex="-1"><a class="header-anchor" href="#销毁" aria-hidden="true">#</a> 销毁</h3><p><strong>实现思路</strong>：</p><p>遍历每一个结点，执行删除操作，删除操作与上面的删除指定数据的结点思路是一致的。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">destroyDlist</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Hnode</span> <span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> delNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> watcher <span class="token operator">=</span> list<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>rlink<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> toDel <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>watcher<span class="token operator">-&gt;</span>rlink<span class="token punctuation">)</span><span class="token punctuation">{</span>
        toDel <span class="token operator">=</span> watcher<span class="token punctuation">;</span>
        watcher<span class="token operator">-&gt;</span>llink<span class="token operator">-&gt;</span>rlink <span class="token operator">=</span> watcher<span class="token operator">-&gt;</span>rlink<span class="token punctuation">;</span>
        watcher<span class="token operator">-&gt;</span>rlink<span class="token operator">-&gt;</span>llink <span class="token operator">=</span> watcher<span class="token operator">-&gt;</span>llink<span class="token punctuation">;</span>
        watcher <span class="token operator">=</span> watcher<span class="token operator">-&gt;</span>rlink<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>toDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
        delNum<span class="token operator">++</span><span class="token punctuation">;</span>
        list<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>data<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token operator">-&gt;</span>head <span class="token operator">=</span> list<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    delNum<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> delNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),y=s("p",null,[s("strong",null,"时间复杂度"),n("：由于需要遍历用户输入的所有数据，执行次数与用户输入规模线性相关，因此时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),x=s("p",null,[s("strong",null,"空间复杂度"),n("：由于删除操作只需要使用固定的变量空间，因此认为空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),f=a('<h2 id="双向链表优缺点" tabindex="-1"><a class="header-anchor" href="#双向链表优缺点" aria-hidden="true">#</a> 双向链表优缺点</h2><p><strong>优点</strong>：</p><ol><li>可以找到前驱和后继，向前遍历和向后遍历。</li><li>在当前结点前面、后面插入操作方便</li><li>针对前驱、后继以及结点本身的删除操作方便。</li></ol><p><strong>缺点</strong>：</p><ol><li>增加删除结点操作复杂。</li><li>较单链表需要占据更多的指针空间。</li><li>存储密度较单链表低。</li></ol>',5),_=[l,c,i,r,u,d,k,m,h,v,g,w,b,y,x,f];function N(M,O){return e(),p("div",null,_)}const D=t(o,[["render",N],["__file","DoubleLinkedList.html.vue"]]);export{D as default};
