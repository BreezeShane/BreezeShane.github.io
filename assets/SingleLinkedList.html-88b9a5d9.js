import{_ as t,W as e,X as p,a1 as a,Y as s,Z as n}from"./framework-68a75bb9.js";const l="/images/DataStructuresAndAlgorithms/SingleLinkedList.png",o={},c=a('<h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><blockquote><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。</p><p>单链表结构：</p><ol><li>头指针结构</li><li>头结点结构</li><li>数据结点</li></ol></blockquote><p>如图所示：</p><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>结构定义的代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="单链表基本操作与代码实现" tabindex="-1"><a class="header-anchor" href="#单链表基本操作与代码实现" aria-hidden="true">#</a> 单链表基本操作与代码实现</h2><h3 id="创建" tabindex="-1"><a class="header-anchor" href="#创建" aria-hidden="true">#</a> 创建</h3><p><strong>实现思路</strong>：</p><p>创建一个空链表，亦是新建一个头指针和一个头结点，创建时注意初始化。</p><p>头指针起指示起点作用，头结点内的数据区域用来存放当前链表的结点总数量「不含头指针和头结点本身」。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//创建带有头结点的单链表</span>
<span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span><span class="token function">mycreateList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> HEAD <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	HEAD<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>HEAD <span class="token operator">||</span> <span class="token operator">!</span>p<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">return</span> HEAD<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,13),i=s("p",null,[s("strong",null,"时间复杂度"),n("：语句的操作次数与用户的输入规模无关，仅执行常数条语句，因此认为时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),r=s("p",null,[s("strong",null,"空间复杂度"),n("：执行该函数只需申请固定的空间大小，因此可以认为该函数空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),u=a(`<h3 id="插入" tabindex="-1"><a class="header-anchor" href="#插入" aria-hidden="true">#</a> 插入</h3><h4 id="在表头插入" tabindex="-1"><a class="header-anchor" href="#在表头插入" aria-hidden="true">#</a> 在表头插入</h4><p><strong>实现思路</strong>：</p><p>在头结点和头结点的后一结点之间插入新的结点，考虑到指针和操作系统的特性，有关指针的操作需要注意，应该先由新结点指向头结点的后一结点，然后才能由头结点指向新结点。</p><p><strong>注意</strong>：因为如果先由头结点指向新结点的话，原先头结点指向的原数据域就会完全丢失，丢失到数据流中无法找回。这是因为原数据域的地址我们本来就不知道，现在还没有指针能够指向它，那么想访问这一数据域显然无从下手。另外，这也造成了一个问题：内存泄漏「Memory Leak」，丢失的内存块我们无法访问，自然也就无法释放它，它毫无用处，却还在占用系统资源，只有当主程序运行结束后由操作系统回收才能解决这个问题。</p><blockquote><p>内存泄漏形象的比喻是“操作系统可提供给所有程序使用的内存空间正在被某个程序榨干”，最终结果是程序运行时间越长，占用内存空间越来越多，最终用尽全部内存空间，整个系统崩溃。</p></blockquote><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">myinsertHead</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> insData <span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	tmp<span class="token operator">-&gt;</span>data <span class="token operator">=</span> insData<span class="token punctuation">;</span>
	tmp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),m=s("p",null,[s("strong",null,"时间复杂度"),n("：仅作有限个指针值修改等的操作，因此时间复杂度是"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),d=s("p",null,[s("strong",null,"空间复杂度"),n("：仅申请了一个结点空间，与用户输入的规模无关，因此时间复杂度是"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),k=a(`<h4 id="在表尾插入" tabindex="-1"><a class="header-anchor" href="#在表尾插入" aria-hidden="true">#</a> 在表尾插入</h4><p><strong>实现思路</strong>：</p><p>显然在表尾插入，需要先遍历到表尾才能在此基础上做插入。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">myinsertTail</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>  head <span class="token punctuation">,</span> <span class="token keyword">int</span> insData <span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	tmp<span class="token operator">-&gt;</span>data <span class="token operator">=</span> insData<span class="token punctuation">;</span>
	tmp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> pointer <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>pointer<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
		pointer<span class="token operator">=</span>pointer<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	pointer<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),h=s("p",null,[s("strong",null,"时间复杂度"),n("：因为需要从表头开始一直向后遍历直到表尾，因此需要访问"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n("个结点，最后指针接上新的结点，因此认为时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),g=s("p",null,[s("strong",null,"空间复杂度"),n("：由于只需要申请常数个新变量的空间大小，因此认为空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),v=a(`<h3 id="输出" tabindex="-1"><a class="header-anchor" href="#输出" aria-hidden="true">#</a> 输出</h3><p><strong>实现思路</strong>：</p><p>遍历每一个结点，并将该结点对应的真值输出。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">myprintList</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> pointer <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>pointer<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> pointer<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pointer <span class="token operator">=</span> pointer<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),x=s("p",null,[s("strong",null,"时间复杂度"),n("：因为需要从表头开始一直向后遍历直到表尾，因此需要访问"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n("个结点，故时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),w=s("p",null,[s("strong",null,"空间复杂度"),n("：由于只需要申请常数个新变量的空间大小，因此认为空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),y=a(`<h3 id="逆置" tabindex="-1"><a class="header-anchor" href="#逆置" aria-hidden="true">#</a> 逆置</h3><p><strong>实现思路</strong>：</p><p>要将链表中所有结点的顺序逆置，考虑到结点插入方式的特性，选用头插法可以实现</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//将正序的链表倒序链接</span>
<span class="token keyword">void</span> <span class="token function">reverseList_link</span><span class="token punctuation">(</span> <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> saver <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> headNode <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> <span class="token operator">*</span>tailNode <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	tailNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>saver<span class="token punctuation">)</span><span class="token punctuation">{</span>
		tmp <span class="token operator">=</span> saver<span class="token punctuation">;</span>
		saver <span class="token operator">=</span> saver<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		tmp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> headNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        headNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),b=s("p",null,[s("strong",null,"时间复杂度"),n("：由于要针对"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"n-1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n("个数据进行插入操作，因此可以认为时间复杂度是"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),f=s("p",null,[s("strong",null,"空间复杂度"),n("：由于插入操作是基于原有空间上进行的，并且申请了有限个常数个的变量空间，因此认为空间复杂度是"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),_=a(`<h3 id="查询" tabindex="-1"><a class="header-anchor" href="#查询" aria-hidden="true">#</a> 查询</h3><h4 id="查询指定值的索引" tabindex="-1"><a class="header-anchor" href="#查询指定值的索引" aria-hidden="true">#</a> 查询指定值的索引</h4><p><strong>实现思路</strong>：</p><p>查找指定值对应的索引，就需要从表头开始向后遍历，并开始从0计数，找到指定值时返回计得的数，否则返回未找到的信号「如-1等」。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">locateNode</span><span class="token punctuation">(</span> <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> headNode <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> linkWatcher <span class="token operator">=</span> headNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>linkWatcher<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>linkWatcher<span class="token operator">-&gt;</span>data <span class="token operator">==</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> index<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        linkWatcher <span class="token operator">=</span> linkWatcher<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        index<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),M=s("p",null,[s("strong",null,"时间复杂度"),n("：详情可见线性表的查询分析，时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),L=s("p",null,[s("strong",null,"空间复杂度"),n("：该操作只需要申请常数个变量，因而空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),O=s("h4",{id:"查询指定索引的值",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#查询指定索引的值","aria-hidden":"true"},"#"),n(" 查询指定索引的值")],-1),N=s("p",null,[s("strong",null,"实现思路"),n("：")],-1),W=s("p",null,[n("获取用户输入的索引记为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n("，在有效范围"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mn",null,"0"),s("mo",null,"≤"),s("mi",null,"n"),s("mo",null,"<"),s("mi",null,"N"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"(0\\leq n < N)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"0"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5782em","vertical-align":"-0.0391em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mclose"},")")])])]),n("内，从表头开始向后遍历，遍历"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n("次后返回指针指向的数据区域的值；若超出范围则返回未找到的信号「如-1等」。")],-1),D=a(`<p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">locateNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> headNode <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> linkWatcher <span class="token operator">=</span> headNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> headNode<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> position<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        linkWatcher <span class="token operator">=</span> linkWatcher<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> linkWatcher<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),q=s("p",null,[s("strong",null,"时间复杂度"),n("：详情可见线性表的查询分析，时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),A=s("p",null,[s("strong",null,"空间复杂度"),n("：该操作只需要申请常数个变量，因而空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),U=a(`<h3 id="销毁" tabindex="-1"><a class="header-anchor" href="#销毁" aria-hidden="true">#</a> 销毁</h3><p><strong>实现思路</strong>：</p><p>因为链表是分散分布在内存空间中的，不能一次性批量释放，只能顺着链表一节一节地释放。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">destroyList</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> deletedNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>firstNode <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>firstNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tmp <span class="token operator">=</span> firstNode<span class="token punctuation">;</span>
        firstNode <span class="token operator">=</span> firstNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        deletedNum<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> deletedNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),z=s("p",null,[s("strong",null,"时间复杂度"),n("：该操作执行次数与用户输入规模大小线性相关，因此时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),E=s("p",null,[s("strong",null,"空间复杂度"),n("：该操作只需要在原有数据基础上进行释放空间，仅需要申请有限个变量的空间，因此空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),H=a('<h2 id="单链表的优缺点" tabindex="-1"><a class="header-anchor" href="#单链表的优缺点" aria-hidden="true">#</a> 单链表的优缺点</h2><p><strong>优点</strong>：</p><ol><li>插入、删除操作十分简单高效。</li><li>不需要指定固定的初始化空间大小。</li><li>不会造成内存空间浪费。</li></ol><p><strong>缺点</strong>：</p><ol><li>查询操作低效。</li><li>只能单向遍历，任何一个结点都只能访问其后继，无法访问前驱。</li><li>存储元素较数组需要的内存空间更大。</li></ol><h2 id="单链表对应的一些难题" tabindex="-1"><a class="header-anchor" href="#单链表对应的一些难题" aria-hidden="true">#</a> 单链表对应的一些难题--&gt;<a href=""></a></h2>',6),S=[c,i,r,u,m,d,k,h,g,v,x,w,y,b,f,_,M,L,O,N,W,D,q,A,U,z,E,H];function B(V,T){return e(),p("div",null,S)}const Y=t(o,[["render",B],["__file","SingleLinkedList.html.vue"]]);export{Y as default};
