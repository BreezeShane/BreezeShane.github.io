import{_ as t,W as e,X as p,a1 as a,Y as s,Z as n}from"./framework-68a75bb9.js";const o={},l=a(`<h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>循环链表，即令单链表尾结点的指针指向链表的头结点。</p><p>结构代码的定义：「本质上与单链表的结构体定义并无差异」</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="循环链表的出现原因" tabindex="-1"><a class="header-anchor" href="#循环链表的出现原因" aria-hidden="true">#</a> 循环链表的出现原因</h2><p>由于单链表在遍历上存在问题，而且尾结点的指针空间也并未利用起来，在需要快速访问表头和表尾的应用中，比较自然的想法就是尾结点直接连接到首结点「即第一个数据结点」。</p><h2 id="循环链表的基本操作及实现" tabindex="-1"><a class="header-anchor" href="#循环链表的基本操作及实现" aria-hidden="true">#</a> 循环链表的基本操作及实现</h2><h3 id="创建" tabindex="-1"><a class="header-anchor" href="#创建" aria-hidden="true">#</a> 创建</h3><p><strong>实现思路</strong>：</p><p>创建空的循环链表，即只需要创建头指针和头结点，并且头指针指向头结点，头结点指向自己。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span><span class="token function">createRlist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> HEAD <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> headNode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    HEAD<span class="token operator">-&gt;</span>next <span class="token operator">=</span> headNode<span class="token punctuation">;</span>
    headNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> headNode<span class="token punctuation">;</span>
    headNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> HEAD<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12),c=s("p",null,[s("strong",null,"时间复杂度"),n("：只需要执行有限个创建的操作，因此时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),i=s("p",null,[s("strong",null,"空间复杂度"),n("：创建时只需要申请有限固定的空间大小，与用户输入规模无关，因此空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),r=a(`<h3 id="插入" tabindex="-1"><a class="header-anchor" href="#插入" aria-hidden="true">#</a> 插入</h3><p><strong>实现思路</strong>：</p><p>思路和单链表的插入思路十分相似，因此在此不作赘述。下面给出的插入方式是按照升序方式插入。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//按照升序方式插入循环链表</span>
<span class="token keyword">void</span> <span class="token function">insertOrder</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">int</span> insData<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> tailNode <span class="token operator">=</span> list<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> headNode <span class="token operator">=</span> tailNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> insData<span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>headNode <span class="token operator">==</span> tailNode<span class="token punctuation">)</span><span class="token punctuation">{</span>
        tailNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        newNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> headNode<span class="token punctuation">;</span>
        list<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        headNode<span class="token operator">-&gt;</span>data<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tailNode<span class="token operator">-&gt;</span>data <span class="token operator">&lt;</span> newNode<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
        newNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tailNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        tailNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        list<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        headNode<span class="token operator">-&gt;</span>data<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> beforeInsertposition <span class="token operator">=</span> headNode<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> insertPosition <span class="token operator">=</span> headNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>insertPosition <span class="token operator">!=</span> headNode<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode<span class="token operator">-&gt;</span>data <span class="token operator">&lt;</span> insertPosition<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        beforeInsertposition <span class="token operator">=</span> beforeInsertposition<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        insertPosition <span class="token operator">=</span> insertPosition<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    beforeInsertposition<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> insertPosition<span class="token punctuation">;</span>
    headNode<span class="token operator">-&gt;</span>data<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),u=s("p",null,[s("strong",null,"时间复杂度"),n("：对于用户输入的"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n("个数据中，每插入一个数据都需要在循环链表中遍历"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"m")]),s("annotation",{encoding:"application/x-tex"},"m")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"m")])])]),n("次，因此可以估计时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])]),s("span",{class:"mclose"},")")])])]),n("。")],-1),d=s("p",null,[s("strong",null,"空间复杂度"),n("：由于用户插入循环链表的操作是基于原有的数据上进行操作，因此可以认为空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),k=a(`<h3 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h3><p><strong>实现思路</strong>：</p><p>遍历循环链表中的每一个结点，循环终止条件是遍历到头结点。在遍历每一结点中若值相同则进行删除操作，即删除结点的前驱指向删除结点的后继，因此需要有两个变量同步遍历链表，</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//删除链表中所有的指定值</span>
<span class="token keyword">int</span> <span class="token function">deleteData</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span>  <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">int</span> delData<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> tailNode <span class="token operator">=</span> list<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> headNode <span class="token operator">=</span> tailNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> formerWatcher <span class="token operator">=</span> headNode<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> latterWatcher <span class="token operator">=</span> headNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>latterWatcher <span class="token operator">!=</span> headNode<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>latterWatcher<span class="token operator">-&gt;</span>data <span class="token operator">==</span> delData<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> toDel <span class="token operator">=</span> latterWatcher<span class="token punctuation">;</span>
            formerWatcher<span class="token operator">-&gt;</span>next <span class="token operator">=</span> latterWatcher<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            latterWatcher <span class="token operator">=</span> latterWatcher<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>toDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        formerWatcher <span class="token operator">=</span> formerWatcher<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        latterWatcher <span class="token operator">=</span> latterWatcher<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    headNode<span class="token operator">-&gt;</span>data <span class="token operator">-=</span> count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),m=s("p",null,[s("strong",null,"时间复杂度"),n("：遍历循环链表的每一个结点显然已有时间复杂度"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("，如果每找到对应的要删除的元素，都会另外单独遍历循环链表来删除相同值的所有元素，相应的时间复杂度也是"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("，因此认为时间复杂度应为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])]),s("span",{class:"mclose"},")")])])]),n("。")],-1),h=s("p",null,[s("strong",null,"空间复杂度"),n("：由于删除的操作仅需要固定的变量即可完成，因此空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),v=a(`<h3 id="输出" tabindex="-1"><a class="header-anchor" href="#输出" aria-hidden="true">#</a> 输出</h3><p><strong>实现思路</strong>：</p><p>在循环链表中，遍历每一个结点并输出其存储的数据，如果使用<code>do ... while</code>句式，终止的条件是遍历到尾结点；如果使用<code>for</code>、<code>while</code>等句式，终止的条件应该是遍历到头结点。两者并无本质区别，写法不同，只是需要保证每遍历到一个结点的时候都要能输出其相应的数据。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">printRlist</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>list<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> tempPointer <span class="token operator">=</span> list<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">do</span><span class="token punctuation">{</span>
        tempPointer<span class="token operator">=</span>tempPointer<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d &quot;</span><span class="token punctuation">,</span> tempPointer<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>tempPointer <span class="token operator">!=</span> list<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),g=s("p",null,[s("strong",null,"时间复杂度"),n("：需要遍历循环链表中的每一个元素，该函数的执行次数与用户输入的数据规模线性相关，因此时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),w=s("p",null,[s("strong",null,"空间复杂度"),n("：该函数需要申请固定的变量空间大小，因此空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),b=a(`<h3 id="销毁" tabindex="-1"><a class="header-anchor" href="#销毁" aria-hidden="true">#</a> 销毁</h3><p><strong>实现思路</strong>：</p><p>遍历每一个结点，并由指针变量指向该结点的后继，然后释放该结点的空间。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">destroyRlist</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>list<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> tailNode <span class="token operator">=</span> list<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> linkSaver <span class="token operator">=</span> tailNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> toDel <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> delValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    delValue <span class="token operator">=</span> tailNode<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>linkSaver <span class="token operator">!=</span> tailNode<span class="token punctuation">)</span><span class="token punctuation">{</span>
        toDel <span class="token operator">=</span> linkSaver<span class="token punctuation">;</span>
        linkSaver <span class="token operator">=</span> linkSaver<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>toDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>tailNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> delValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),x=s("p",null,[s("strong",null,"时间复杂度"),n("：该函数执行次数与用户的输入规模线性相关，因此可以认为时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),y=s("p",null,[s("strong",null,"空间复杂度"),n("：该函数申请固定的空间大小，不随用户输入规模变化而变化，因此认为空间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),f=a(`<h3 id="查找" tabindex="-1"><a class="header-anchor" href="#查找" aria-hidden="true">#</a> 查找</h3><p><strong>实现思路</strong>：</p><p>这里实现的思路和单链表查找的思路是完全一致的，因此不再赘述。</p><p><strong>源代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//查找指定数据是否存在链表中</span>
<span class="token keyword">int</span> <span class="token function">searchforData</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> headNode <span class="token operator">=</span> list<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> linkWatcher <span class="token operator">=</span> headNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>linkWatcher <span class="token operator">!=</span> headNode<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>linkWatcher<span class="token operator">-&gt;</span>data <span class="token operator">==</span> data<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        linkWatcher <span class="token operator">=</span> linkWatcher<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),N=s("p",null,[s("strong",null,"时间复杂度"),n("：详细分析请查看单链表查询，这里直接给出结果"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),_=s("p",null,[s("strong",null,"空间复杂度"),n("：详细分析请查看单链表查询，这里直接给出结果"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("。")],-1),M=s("h3",{id:"关于循环链表的一些问题",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#关于循环链表的一些问题","aria-hidden":"true"},"#"),n(),s("a",{href:""},"关于循环链表的一些问题")],-1),O=[l,c,i,r,u,d,k,m,h,v,g,w,b,x,y,f,N,_,M];function L(W,D){return e(),p("div",null,O)}const z=t(o,[["render",L],["__file","CircularLinkedList.html.vue"]]);export{z as default};
