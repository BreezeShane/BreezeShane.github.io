import{_ as e,W as l,X as r,Y as a,Z as t,$ as s,a1 as o,C as i}from"./framework-68a75bb9.js";const h={},c={class:"hint-container details"},p=a("summary",null,"参考",-1),m={href:"https://www.bookstack.cn/read/hunterhug-goa.c/basic-dregee.md#3.4.%20%E6%B8%90%E8%BF%9B%E5%88%86%E6%9E%90",target:"_blank",rel:"noopener noreferrer"},d={href:"https://zhuanlan.zhihu.com/p/362214924",target:"_blank",rel:"noopener noreferrer"},u={href:"https://g0ul4sh.top/2017/09/26/big-o-notation/",target:"_blank",rel:"noopener noreferrer"},_={href:"https://blog.csdn.net/a22222259/article/details/88349669",target:"_blank",rel:"noopener noreferrer"},g={href:"https://blog.csdn.net/so_geili/article/details/53444816",target:"_blank",rel:"noopener noreferrer"},x={href:"https://codeantenna.com/a/cEzNAzRqZ1",target:"_blank",rel:"noopener noreferrer"},k={href:"https://zhuanlan.zhihu.com/p/267890781",target:"_blank",rel:"noopener noreferrer"},w={href:"https://blog.csdn.net/every__day/article/details/86554857",target:"_blank",rel:"noopener noreferrer"},f={href:"https://blog.csdn.net/so_geili/article/details/53444816",target:"_blank",rel:"noopener noreferrer"},b=o('<h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h2><p>一个算法问题的<strong>规约</strong>(Specification)主要包括两部分:</p><ul><li><strong>输入</strong>: 明确规定了算法接受的所有合法输入.</li><li><strong>输出</strong>: 明确规定了对于每一个合法的输入值, 相应的输出值应该是什么.</li></ul><p><strong>算法</strong>是为了解决某个问题的一系列运算或操作.</p><p><strong>问题的实例</strong>(Instance)是计算该问题解所必须的(满足问题陈述中强加的各种约束的)输入组成.</p>',5),M=a("p",null,[t("若把问题"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"P")]),a("annotation",{encoding:"application/x-tex"},"P")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"P")])])]),t("的任何实例作为算法"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"A")]),a("annotation",{encoding:"application/x-tex"},"A")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"A")])])]),t("的输入, "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"A")]),a("annotation",{encoding:"application/x-tex"},"A")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"A")])])]),t("能够在有限步后停机, 并输出该实例正确的解, 我们称这个过程为算法"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"A")]),a("annotation",{encoding:"application/x-tex"},"A")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"A")])])]),t("解决问题"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"P")]),a("annotation",{encoding:"application/x-tex"},"P")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"P")])])]),t(".")],-1),y=a("h2",{id:"计算复杂性",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#计算复杂性","aria-hidden":"true"},"#"),t(" 计算复杂性")],-1),A=a("p",null,[t("针对任何输入规模"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"n")]),a("annotation",{encoding:"application/x-tex"},"n")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"n")])])]),t(", 任意一个算法都必然要消耗一段时间才能得出解. 这自然会区分出算法计算速度的快与慢, 资源使用效率的高与低, 性能发挥的优与劣. 为了能够系统性地, 科学性地衡量一个算法, 我们就产生了一系列的衡量, 这些衡量有着共同的数学概念与模型: 函数渐进的界.")],-1),E=a("p",null,"(这里是施工现场, 我正在填坑了, 您先等等, 别着急......ToT)",-1);function B(L,z){const n=i("ExternalLinkIcon");return l(),r("div",null,[a("details",c,[p,a("ol",null,[a("li",null,[a("a",m,[t("算法复杂度及渐进符号"),s(n)])]),a("li",null,[a("a",d,[t("渐近记号、算法复杂度与主定理"),s(n)])]),a("li",null,[a("a",u,[t("大 O 记号及算法的时间复杂度"),s(n)])]),a("li",null,[a("a",_,[t("算法复杂性分析及运算规则证明(二)"),s(n)])]),a("li",null,[a("a",g,[t("算法导论------递归算法的时间复杂度求解"),s(n)])]),a("li",null,[a("a",x,[t("递归方程的求解（代入、递归树和主方法）"),s(n)])]),a("li",null,[a("a",k,[t("递归式求解——代入法、递归树与主定理"),s(n)])]),a("li",null,[a("a",w,[t("递归树： 如何借助树来求解递归算法的时间复杂度"),s(n)])]),a("li",null,[a("a",f,[t("算法导论------递归算法的时间复杂度求解"),s(n)])])])]),b,M,y,A,E])}const N=e(h,[["render",B],["__file","Basis.html.vue"]]);export{N as default};
